# Anti-Offside Python (aopy)

## 概要

Pythonのオフサイドルールは私にとって「Not For Me」なため、「波括弧」を使用する一般的なプログラミングスタイルでPythonスクリプトを記述できるトランスレーターを作りました。

## aopy.pyの使い方

aopy.pyには2つの動作モードがあります。

### インタプリターモード

.aopy ファイルをトランスレートし、その結果得られた Python コードをそのまま Python インタプリタで実行します。

``` bash
python aopy.py test.aopy
```

`config.json`の`cacheFile`で指定されたファイルに Python コードを出力し、即座に実行します。コマンドライン引数は sys.argv から .aopy ファイルの指定部分を除外した状態で渡されます。ファイルを指定しなかった場合は標準入力からaopyコードを受け取ります。

`cacheFile`が空の場合、トランスレートされたコードは exec 関数で実行されます。この場合、コマンドライン引数は反映されません。

### トランスパイラモード

`-o` オプションを使用して出力ファイル名を指定することにより、トランスパイルされたコードを指定されたファイルに出力します。

``` bash
python aopy.py test.aopy -o test.py
```

このコマンドを実行すると、`test.aopy` をトランスパイルして、その結果を `test.py` に出力します。

復数のファイルの入力及び出力には対応していません。

`config.json`の`useInterpreter`を`false`にするとコマンドラインの引数に関係なくトランスパイラモードで動作します。

この設定で`-o`で出力ファイルを指定しなかった場合は標準出力にトランスパイル済みのコードを出力します。

## 変換例

変換前

```python
def test() {
  print("Hello, World!")
  if (False) {
    print("nest")
  } else {
    print("nest else")
  }
  if (False) {
    #行末にスペースを入れているので辞書リテラル扱い
    test1 = { 
      "dict" : "test"
    }
  }
  #二重波括弧は行末でも辞書リテラル扱い
  if (True) : test2 = {{
      'a' : 50,
      #ネストにも対応、位置にかかわらず辞書リテラル内の波括弧は常に辞書リテラル扱い
      'b' : {
        'c' : 100
      }
  }}
  print("test")
  #位置に関わらず:{はブロック開始扱い
  if (True) :{ 
    print("test3")
  }
  if (False) :{ print("oneline") }
  print("indent?")
}

test()
```

変換後

```python
def test() :
    print("Hello, World!")
    if (False) :
        print("nest")
    else :
        print("nest else")
    if (False) :
        test1 = {
            "dict" : "test"
        }
    if (True) : test2 = {
        'a' : 50,
        'b' : {
            'c' : 100
        }
    }
    print("test")
    if (True) :
        print("test3")
    if (False) : print("oneline")
    print("indent?")
test()
```

## 言語仕様

Aopyはオフサイドルールを使用せずにトランスレーターを構築するために、以下の二つのモードを提供しています。

### シンプルモード

* 原則として、波括弧`{`はブロックの開始、`}`はブロックの終了として処理します。
* ノーマルモードとの互換性のために、`:{`もブロックの開始として処理します。
* 二重の波括弧`{{`および`}}`は辞書型リテラルの波括弧として処理します。
* 単一行のコメント`#`は削除されますが、三重クオートの複数行コメントはそのまま残ります。
* 文字列リテラル内にある波括弧やコメント記号も通常のコードと同様に解釈されます。
* `{`, `}`, `#` を文字として扱いたい場合、それぞれ`__BEGINBRACE__`, `__ENDBRACE__`, `__SHARP__`と記述する必要があります。
* このモードは基本的にノーマルモードのトランスレーターを生成するためのものであり、通常の使用目的には適していません。

### ノーマルモード

* 行末にある単独の波括弧`{`はブロックの開始と解釈します。
* その他の単独の波括弧は辞書リテラルの開始と解釈します。
* 単一行コメント`#`は`config.json`の`removeComment`が`true`の場合のみ削除します、三重クオートの複数行コメントは設定に関わらずそのまま残ります。
* 位置に関わらず、`:{`はブロックの開始、`{{`は辞書リテラルの開始と解釈します。
* `}`は、直前の`{`の解釈や辞書リテラルのネストに応じて適切に処理されます、辞書リテラルがブロックをまたぐことは、Pythonの言語仕様上ありえません。
* シンプルモードとの互換性のため`}}`はノーマルモードでは`{`を辞書リテラルの開始と解釈している場合のみ`}`と同様に扱います。
* 文字列リテラル内でも、`__BEGINBRACE__`, `__ENDBRACE__`, `__SHARP__`はそれぞれ`{`, `}`, `#`に変換されます。これらを文字列として使用したい場合は、`___BEGINBRACE___`のようにアンダースコアを増やしてください。
